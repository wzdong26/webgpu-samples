import{p as S}from"./position.frag.ff5a6327.js";import{p as w,u as y,v as B,a as A,b as M,g as R}from"./matrix.2969bbb4.js";import{o as T}from"./resizeObserver.84f51a4b.js";var z=`@binding(0) @group(0) var<storage, read> mvpMatrix : array<mat4x4<f32>>;

struct VertexOutput {
    @builtin(position) Position: vec4<f32>,
    @location(0) fragUV: vec2<f32>,
    @location(1) fragPosition: vec4<f32>
};

@vertex
fn main(
    @builtin(instance_index) index: u32,
    @location(0) position: vec4<f32>,
    @location(1) uv: vec2<f32>
) -> VertexOutput {
    var output: VertexOutput;
    output.Position = mvpMatrix[index] * position;
    output.fragUV = uv;
    output.fragPosition = 0.5 * (position + vec4<f32>(1.0));
    return output;
}`;function N(r,o){const{on:s,off:n}=q(o),t=D(r,s);return async()=>{(await t)(),n()}}const L=["renderInstance","renderBundle"];function q(r){const o=document.createElement("select"),s=L.map(t=>{const e=document.createElement("option");return e.value=t,e.innerText=t,e});o.append(...s),r.append(o);let n;return{on:async(t,e)=>{n&&o.removeEventListener("input",n),n=async({target:i})=>{const{value:u}=i||{};await t(u)},o.addEventListener("input",n),e&&await n({target:o})},off:()=>{n&&o.removeEventListener("input",n),r.removeChild(o)}}}const f=1e3;function _(r){const o=[],s=new Float32Array(f*4*4);for(let n=0;n<f;n++){const t={x:Math.random()*40-20,y:Math.random()*40-20,z:-30-Math.random()*50},e={x:0,y:0,z:0},i={x:1,y:1,z:1};o.push({position:t,rotation:e,scale:i})}return function(t){t=t/1e3;for(let e=0;e<o.length-1;e++){const i=o[e];i.rotation.x=Math.sin(t+e),i.rotation.y=Math.cos(t+e);const u=R(r,i.position,i.rotation,i.scale);s.set(u,e*4*4)}return s}}async function D(r,o){const{gpu:s}=navigator,n=await s.requestAdapter({});if(!n)throw Error("WebGPU not support! Adapter not found!");const t=s.getPreferredCanvasFormat();if(!t)throw Error("WebGPU not support! Adapter not found!");const e=await n.requestDevice(),i=r.getContext("webgpu"),{devicePixelRatio:u=1}=window;i.configure({device:e,format:t,alphaMode:"opaque"});const g=e.createRenderPipeline({vertex:{module:e.createShaderModule({code:z}),entryPoint:"main",buffers:[{attributes:[{shaderLocation:0,offset:0,format:`float32x${w}`},{shaderLocation:1,offset:4*w,format:`float32x${y}`}],arrayStride:4*(w+y),stepMode:"vertex"}]},fragment:{module:e.createShaderModule({code:S}),entryPoint:"main",targets:[{format:t}]},primitive:{topology:"triangle-list",cullMode:"back"},depthStencil:{depthWriteEnabled:!0,depthCompare:"less",format:"depth24plus"},layout:"auto"}),v=e.createBuffer({size:B.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST});e.queue.writeBuffer(v,0,B,0,B.length);const{write:O,setGroup:P}=F(e,g);let l,E;const b=a=>{const{width:d,height:c,clientHeight:p,clientWidth:m}=r;if(a&&d===m*u&&c===p*u)return;const h={width:r.clientWidth*u,height:r.clientHeight*u};Object.assign(r,h),l==null||l.destroy(),l=e.createTexture({size:h,format:"depth24plus",usage:GPUTextureUsage.RENDER_ATTACHMENT}),E=_(h.width/h.height)};b();const V=T(r,b);function C(){const a={colorAttachments:[{view:void 0,clearValue:{r:.5,g:.5,b:.5,a:1},loadOp:"clear",storeOp:"store"}],depthStencilAttachment:{view:l.createView(),depthClearValue:1,depthLoadOp:"clear",depthStoreOp:"store"}};return()=>{const d=e.createCommandEncoder();a.colorAttachments[0].view=i.getCurrentTexture().createView();const c=d.beginRenderPass(a);c.setPipeline(g),c.setVertexBuffer(0,v),P(c),c.draw(M,f),c.end(),e.queue.submit([d.finish()])}}function U(){const a=e.createRenderBundleEncoder({colorFormats:[t],depthStencilFormat:"depth24plus"});a.setPipeline(g),console.time("recordBundles");for(let p=0;p<f;p++)a.setVertexBuffer(0,v),P(a),a.draw(M,1,0,p);console.timeEnd("recordBundles");const d=[a.finish()],c={colorAttachments:[{view:void 0,clearValue:{r:0,g:0,b:0,a:1},loadOp:"clear",storeOp:"store"}],depthStencilAttachment:{view:l.createView(),depthClearValue:1,depthLoadOp:"clear",depthStoreOp:"store"}};return()=>{const p=e.createCommandEncoder();c.colorAttachments[0].view=i.getCurrentTexture().createView();const m=p.beginRenderPass(c);m.executeBundles(d),m.end(),e.queue.submit([p.finish()])}}let x;await o(a=>{a==="renderBundle"?x=U():x=C()},!0);const G=A(a=>{const d=E(a);O(d),x()});return()=>{G(),V()}}function F(r,o){const s=r.createBuffer({size:64*f,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),n=r.createBindGroup({layout:o.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:s}}]});return{write(t){r.queue.writeBuffer(s,0,t)},setGroup(t){t.setBindGroup(0,n)}}}export{N as render};
