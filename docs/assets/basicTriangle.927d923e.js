var p=`@vertex\r
fn main(@location(0) position : vec3<f32>) -> @builtin(position) vec4<f32> {\r
    return vec4<f32>(position, 1.0);\r
}`,g=`@group(0) @binding(0) var<uniform> color : vec4<f32>;\r
\r
@fragment\r
fn main() -> @location(0) vec4<f32> {\r
    return color;\r
}`;const a={vertex:new Float32Array([0,.5,0,-.5,-.5,0,.5,-.5,0]),vertexCount:3,color:new Float32Array([1,0,0,1]),vertexInput:new Float32Array([0,.6,0,1,1,0,0,1,-.5,-.6,0,1,0,1,0,1,.5,-.6,0,1,0,0,1,1])};function x(){const e=new WeakMap,t=new ResizeObserver(n=>{var r;for(const o of n)(r=e.get(o.target))==null||r(o)});return{onResize(n,r){return e.set(n,r.bind(n)),t.observe(n),()=>t.unobserve(n)},disconnect:()=>t.disconnect()}}const{onResize:b,disconnect:m}=x();async function P(e){const{device:t,context:n,pipeline:r}=await h(e),o=w(t,r);return d(t,n,r,o),b(e,()=>{e.width=e.clientWidth*devicePixelRatio,e.height=e.clientHeight*devicePixelRatio,d(t,n,r,o)})}async function h(e){var u,f;const{gpu:t}=navigator,n=await((u=t==null?void 0:t.requestAdapter)==null?void 0:u.call(t,{}));if(!n)throw Error("WebGPU not support! Adapter not found!");const r=(f=t.getPreferredCanvasFormat)==null?void 0:f.call(t);if(!r)throw Error("WebGPU not support! Adapter not found!");const o=await n.requestDevice(),i=e.getContext("webgpu"),{devicePixelRatio:c=1}=window,s={width:e.clientWidth*c,height:e.clientHeight*c};Object.assign(e,s),i.configure({device:o,format:r,alphaMode:"opaque"});const l=await v(o,r);return{device:o,context:i,format:r,canvasSize:s,pipeline:l}}function v(e,t){return e.createRenderPipelineAsync({vertex:{module:e.createShaderModule({code:p}),entryPoint:"main",buffers:[{attributes:[{shaderLocation:0,offset:0,format:"float32x3"}],arrayStride:4*3,stepMode:"vertex"}]},fragment:{module:e.createShaderModule({code:g}),entryPoint:"main",targets:[{format:t}]},primitive:{topology:"triangle-list"},layout:"auto"})}function w(e,t){const n=e.createBuffer({size:a.vertex.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST});e.queue.writeBuffer(n,0,a.vertex,0,a.vertex.length);const r=e.createBuffer({size:a.color.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});e.queue.writeBuffer(r,0,a.color,0,a.color.length);const o=e.createBindGroup({layout:t.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:r}}]});return{vertexBuffer:n,colorBuffer:r,uniformGroup:o}}function d(e,t,n,r){const o=e.createCommandEncoder(),i=o.beginRenderPass({colorAttachments:[{view:t.getCurrentTexture().createView(),clearValue:{r:0,g:.5,b:1,a:1},loadOp:"clear",storeOp:"store"}]});i.setPipeline(n),i.setVertexBuffer(0,r.vertexBuffer),i.setBindGroup(0,r.uniformGroup),i.draw(a.vertexCount),i.end(),e.queue.submit([o.finish()])}export{P as render};
