import{b as L}from"./basic.vert.dd86de92.js";import{t as M}from"./texture.frag.3659063c.js";import{p as w,u as C,v as E,a as z,g as V,b as A}from"./matrix.2969bbb4.js";import{o as O}from"./resizeObserver.84f51a4b.js";function X(o,n){const e=N(n),r=D(o,e.target);return async()=>{e(),(await r)()}}function N(o){const n=document.createElement("div");n.innerText="Try drawing on the canvas below:";const e=document.createElement("canvas");o.append(n,e);const r=e.getContext("2d");if(!r)throw new Error("No support 2d");r.fillStyle="#fff",r.lineWidth=5,r.lineCap="round",r.lineJoin="round",r.fillRect(0,0,e.width,e.height);let a=0,t=0,i=0;const u=c=>{a=c.offsetX,t=c.offsetY,document.addEventListener("pointermove",f),document.addEventListener("pointerup",s,{once:!0}),e.addEventListener("pointerout",s,{once:!0})},f=c=>{const l=c.offsetX,m=c.offsetY;i=i>360?0:i+1,r.strokeStyle=`hsl(${i}, 90%, 50%)`,r.beginPath(),r.moveTo(a,t),r.lineTo(l,m),r.stroke(),a=l,t=m},s=()=>document.removeEventListener("pointermove",f);e.addEventListener("pointerdown",u);const p=()=>{s(),document.removeEventListener("pointerup",s),e.removeEventListener("pointerout",s),e.removeEventListener("pointerdown",u),o.removeChild(n),o.removeChild(e)};return p.target=e,p}function _(o,n,e){const r={position:{x:0,y:0,z:-8},rotation:{x:0,y:0,z:0},scale:{x:1,y:1,z:1}};return function(t){t=t/1e3,r.rotation.x=Math.sin(t),r.rotation.y=Math.cos(t);const i=V(e,r.position,r.rotation,r.scale);o.queue.writeBuffer(n,0,i)}}async function D(o,n){var U,y;const{gpu:e}=navigator,r=await((U=e==null?void 0:e.requestAdapter)==null?void 0:U.call(e,{}));if(!r)throw Error("WebGPU not support! Adapter not found!");const a=(y=e.getPreferredCanvasFormat)==null?void 0:y.call(e);if(!a)throw Error("WebGPU not support! Adapter not found!");const t=await r.requestDevice(),i=o.getContext("webgpu"),{devicePixelRatio:u=1}=window;i.configure({device:t,format:a,alphaMode:"premultiplied"});const f=t.createRenderPipeline({vertex:{module:t.createShaderModule({code:L}),entryPoint:"main",buffers:[{attributes:[{shaderLocation:0,offset:0,format:`float32x${w}`},{shaderLocation:1,offset:4*w,format:`float32x${C}`}],arrayStride:4*(w+C),stepMode:"vertex"}]},fragment:{module:t.createShaderModule({code:M}),entryPoint:"main",targets:[{format:a}]},primitive:{topology:"triangle-list",cullMode:"back"},depthStencil:{depthWriteEnabled:!0,depthCompare:"less",format:"depth24plus"},layout:"auto"}),s=t.createBuffer({size:E.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST});t.queue.writeBuffer(s,0,E,0,E.length);const p=t.createBuffer({size:4*4*4,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),c=[n.width,n.height],l=t.createTexture({size:[...c,1],format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT}),m=t.createSampler({magFilter:"linear",minFilter:"linear"}),B=t.createBindGroup({layout:f.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:p}},{binding:1,resource:m},{binding:2,resource:l.createView()}]});let T,b;const P=v=>{const{width:h,height:x,clientHeight:d,clientWidth:G}=o;if(v&&h===G*u&&x===d*u)return;const g={width:o.clientWidth*u,height:o.clientHeight*u};Object.assign(o,g),T=t.createTexture({size:g,format:"depth24plus",usage:GPUTextureUsage.RENDER_ATTACHMENT}).createView(),b=_(t,p,g.width/g.height)};P();const R=O(o,P),S=z(v=>{b(v),t.queue.copyExternalImageToTexture({source:n},{texture:l},c);const h=t.createCommandEncoder(),x=i.getCurrentTexture().createView(),d=h.beginRenderPass({colorAttachments:[{view:x,clearValue:{r:.5,g:.5,b:.5,a:1},loadOp:"clear",storeOp:"store"}],depthStencilAttachment:{view:T,depthClearValue:1,depthLoadOp:"clear",depthStoreOp:"store"}});d.setPipeline(f),d.setVertexBuffer(0,s),d.setBindGroup(0,B),d.draw(A),d.end(),t.queue.submit([h.finish()])});return()=>{S(),R()}}export{X as render};
