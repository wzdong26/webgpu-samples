import{p as U}from"./position.frag.ff5a6327.js";import{p as w,u as b,v as B,a as G,b as y,g as S}from"./matrix.2969bbb4.js";var A=`@binding(0) @group(0) var<storage, read> mvpMatrix : array<mat4x4<f32>>;

struct VertexOutput {
    @builtin(position) Position: vec4<f32>,
    @location(0) fragUV: vec2<f32>,
    @location(1) fragPosition: vec4<f32>
};

@vertex
fn main(
    @builtin(instance_index) index: u32,
    @location(0) position: vec4<f32>,
    @location(1) uv: vec2<f32>
) -> VertexOutput {
    var output: VertexOutput;
    output.Position = mvpMatrix[index] * position;
    output.fragUV = uv;
    output.fragPosition = 0.5 * (position + vec4<f32>(1.0));
    return output;
}`;function W(o,r){const{on:s,off:n}=T(r),t=z(o,s);return async()=>{(await t)(),n()}}const R=["renderInstance","renderBundle"];function T(o){const r=document.createElement("select"),s=R.map(t=>{const e=document.createElement("option");return e.value=t,e.innerText=t,e});r.append(...s),o.append(r);let n;return{on:async(t,e)=>{n&&r.removeEventListener("input",n),n=async({target:i})=>{const{value:u}=i||{};await t(u)},r.addEventListener("input",n),e&&await n({target:r})},off:()=>{n&&r.removeEventListener("input",n),o.removeChild(r)}}}const f=1e3;function L(o){const r=[],s=new Float32Array(f*4*4);for(let n=0;n<f;n++){const t={x:Math.random()*40-20,y:Math.random()*40-20,z:-30-Math.random()*50},e={x:0,y:0,z:0},i={x:1,y:1,z:1};r.push({position:t,rotation:e,scale:i})}return function(t){t=t/1e3;for(let e=0;e<r.length-1;e++){const i=r[e];i.rotation.x=Math.sin(t+e),i.rotation.y=Math.cos(t+e);const u=S(o,i.position,i.rotation,i.scale);s.set(u,e*4*4)}return s}}async function z(o,r){const{gpu:s}=navigator,n=await s.requestAdapter({});if(!n)throw Error("WebGPU not support! Adapter not found!");const t=s.getPreferredCanvasFormat();if(!t)throw Error("WebGPU not support! Adapter not found!");const e=await n.requestDevice(),i=o.getContext("webgpu"),{devicePixelRatio:u=1}=window;i.configure({device:e,format:t,alphaMode:"opaque"});const g=e.createRenderPipeline({vertex:{module:e.createShaderModule({code:A}),entryPoint:"main",buffers:[{attributes:[{shaderLocation:0,offset:0,format:`float32x${w}`},{shaderLocation:1,offset:4*w,format:`float32x${b}`}],arrayStride:4*(w+b),stepMode:"vertex"}]},fragment:{module:e.createShaderModule({code:U}),entryPoint:"main",targets:[{format:t}]},primitive:{topology:"triangle-list",cullMode:"back"},depthStencil:{depthWriteEnabled:!0,depthCompare:"less",format:"depth24plus"},layout:"auto"}),v=e.createBuffer({size:B.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST});e.queue.writeBuffer(v,0,B,0,B.length);const{write:M,setGroup:P}=q(e,g);let l,E;(a=>{const{width:d,height:c,clientHeight:p,clientWidth:m}=o;if(a&&d===m*u&&c===p*u)return;const h={width:o.clientWidth*u,height:o.clientHeight*u};Object.assign(o,h),l==null||l.destroy(),l=e.createTexture({size:h,format:"depth24plus",usage:GPUTextureUsage.RENDER_ATTACHMENT}),E=L(h.width/h.height)})();function O(){const a={colorAttachments:[{view:void 0,clearValue:{r:.5,g:.5,b:.5,a:1},loadOp:"clear",storeOp:"store"}],depthStencilAttachment:{view:l.createView(),depthClearValue:1,depthLoadOp:"clear",depthStoreOp:"store"}};return()=>{const d=e.createCommandEncoder();a.colorAttachments[0].view=i.getCurrentTexture().createView();const c=d.beginRenderPass(a);c.setPipeline(g),c.setVertexBuffer(0,v),P(c),c.draw(y,f),c.end(),e.queue.submit([d.finish()])}}function V(){const a=e.createRenderBundleEncoder({colorFormats:[t],depthStencilFormat:"depth24plus"});a.setPipeline(g),console.time("recordBundles");for(let p=0;p<f;p++)a.setVertexBuffer(0,v),P(a),a.draw(y,1,0,p);console.timeEnd("recordBundles");const d=[a.finish()],c={colorAttachments:[{view:void 0,clearValue:{r:0,g:0,b:0,a:1},loadOp:"clear",storeOp:"store"}],depthStencilAttachment:{view:l.createView(),depthClearValue:1,depthLoadOp:"clear",depthStoreOp:"store"}};return()=>{const p=e.createCommandEncoder();c.colorAttachments[0].view=i.getCurrentTexture().createView();const m=p.beginRenderPass(c);m.executeBundles(d),m.end(),e.queue.submit([p.finish()])}}let x;await r(a=>{a==="renderBundle"?x=V():x=O()},!0);const C=G(a=>{const d=E(a);M(d),x()});return()=>{C()}}function q(o,r){const s=o.createBuffer({size:64*f,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),n=o.createBindGroup({layout:r.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:s}}]});return{write(t){o.queue.writeBuffer(s,0,t)},setGroup(t){t.setBindGroup(0,n)}}}export{W as render};
