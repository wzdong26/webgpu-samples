var d=`@vertex\r
fn main(@location(0) position : vec3<f32>) -> @builtin(position) vec4<f32> {\r
    return vec4<f32>(position, 1.0);\r
}`,p=`@group(0) @binding(0) var<uniform> color : vec4<f32>;\r
\r
@fragment\r
fn main() -> @location(0) vec4<f32> {\r
    return color;\r
}`;const a={vertex:new Float32Array([0,.5,0,-.5,-.5,0,.5,-.5,0]),vertexCount:3,color:new Float32Array([1,0,0,1]),vertexInput:new Float32Array([0,.6,0,1,1,0,0,1,-.5,-.6,0,1,0,1,0,1,.5,-.6,0,1,0,0,1,1])};async function w(e){const{device:t,context:o,pipeline:r}=await g(e),n=x(t,r);v(t,o,r,n)}async function g(e){var f,s;const{gpu:t}=navigator,o=await((f=t==null?void 0:t.requestAdapter)==null?void 0:f.call(t,{}));if(!o)throw Error("WebGPU not support! Adapter not found!");const r=(s=t.getPreferredCanvasFormat)==null?void 0:s.call(t);if(!r)throw Error("WebGPU not support! Adapter not found!");const n=await o.requestDevice(),i=e.getContext("webgpu"),{devicePixelRatio:u=1}=window,c={width:e.clientWidth*u,height:e.clientHeight*u};Object.assign(e,c),i.configure({device:n,format:r,alphaMode:"opaque"});const l=await m(n,r);return{device:n,context:i,format:r,canvasSize:c,pipeline:l}}function m(e,t){return e.createRenderPipelineAsync({vertex:{module:e.createShaderModule({code:d}),entryPoint:"main",buffers:[{attributes:[{shaderLocation:0,offset:0,format:"float32x3"}],arrayStride:4*3,stepMode:"vertex"}]},fragment:{module:e.createShaderModule({code:p}),entryPoint:"main",targets:[{format:t}]},primitive:{topology:"triangle-list"},layout:"auto"})}function x(e,t){const o=e.createBuffer({size:a.vertex.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST});e.queue.writeBuffer(o,0,a.vertex,0,a.vertex.length);const r=e.createBuffer({size:a.color.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});e.queue.writeBuffer(r,0,a.color,0,a.color.length);const n=e.createBindGroup({layout:t.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:r}}]});return{vertexBuffer:o,colorBuffer:r,uniformGroup:n}}function v(e,t,o,r){const n=e.createCommandEncoder(),i=n.beginRenderPass({colorAttachments:[{view:t.getCurrentTexture().createView(),clearValue:{r:0,g:.5,b:1,a:1},loadOp:"clear",storeOp:"store"}]});i.setPipeline(o),i.setVertexBuffer(0,r.vertexBuffer),i.setBindGroup(0,r.uniformGroup),i.draw(a.vertexCount),i.end(),e.queue.submit([n.finish()])}export{w as render};
