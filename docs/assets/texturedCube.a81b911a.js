import{b as R}from"./basic.vert.dd86de92.js";import{t as M}from"./texture.frag.3659063c.js";import{p as m,u as P,v as g,a as O,g as S,b as z}from"./matrix.2969bbb4.js";import{o as V}from"./resizeObserver.84f51a4b.js";var A="/texture.webp",I="/sprites.webp";function Y(n,o){const{on:r,off:t}=L(o),a=N(n,r);return async()=>{(await a)(),t()}}const l={texture:A,sprites:I};async function _(n){const o=l[n];if(typeof o=="string"){const r=new Image;r.src=o,await r.decode();const t=await createImageBitmap(r);return l[n]=t}else return o}function L(n){const o=document.createElement("select"),r=Object.keys(l).map(a=>{const e=document.createElement("option");return e.value=a,e.innerText=a,e});o.append(...r),n.append(o);let t;return{on:async(a,e)=>{t&&o.removeEventListener("input",t),t=async({target:u})=>{const{value:c}=u||{};!l[c]||await a(c)},o.addEventListener("input",t),e&&await t({target:o})},off:()=>{t&&o.removeEventListener("input",t),n.removeChild(o)}}}function D(n,o,r){const t={position:{x:0,y:0,z:-8},rotation:{x:0,y:0,z:0},scale:{x:1,y:1,z:1}};return function(e){e=e/1e3,t.rotation.x=Math.sin(e),t.rotation.y=Math.cos(e);const u=S(r,t.position,t.rotation,t.scale);n.queue.writeBuffer(o,0,u)}}async function N(n,o){var U,y;const{gpu:r}=navigator,t=await((U=r==null?void 0:r.requestAdapter)==null?void 0:U.call(r,{}));if(!t)throw Error("WebGPU not support! Adapter not found!");const a=(y=r.getPreferredCanvasFormat)==null?void 0:y.call(r);if(!a)throw Error("WebGPU not support! Adapter not found!");const e=await t.requestDevice(),u=n.getContext("webgpu"),{devicePixelRatio:c=1}=window;u.configure({device:e,format:a,alphaMode:"premultiplied"});const h=e.createRenderPipeline({vertex:{module:e.createShaderModule({code:R}),entryPoint:"main",buffers:[{attributes:[{shaderLocation:0,offset:0,format:`float32x${m}`},{shaderLocation:1,offset:4*m,format:`float32x${P}`}],arrayStride:4*(m+P),stepMode:"vertex"}]},fragment:{module:e.createShaderModule({code:M}),entryPoint:"main",targets:[{format:a}]},primitive:{topology:"triangle-list",cullMode:"back"},depthStencil:{depthWriteEnabled:!0,depthCompare:"less",format:"depth24plus"},layout:"auto"}),x=e.createBuffer({size:g.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST});e.queue.writeBuffer(x,0,g,0,g.length);const w=e.createBuffer({size:4*4*4,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});let v;await o(async d=>{const i=await _(d),p=e.createTexture({size:[i.width,i.height,1],format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT});e.queue.copyExternalImageToTexture({source:i},{texture:p},[i.width,i.height]);const s=e.createSampler({magFilter:"linear",minFilter:"linear"});v=e.createBindGroup({layout:h.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:w}},{binding:1,resource:s},{binding:2,resource:p.createView()}]})},!0);let b,T;const E=d=>{const{width:i,height:p,clientHeight:s,clientWidth:G}=n;if(d&&i===G*c&&p===s*c)return;const f={width:n.clientWidth*c,height:n.clientHeight*c};Object.assign(n,f),b=e.createTexture({size:f,format:"depth24plus",usage:GPUTextureUsage.RENDER_ATTACHMENT}).createView(),T=D(e,w,f.width/f.height)};E();const B=V(n,E),C=O(d=>{T(d);const i=e.createCommandEncoder(),p=u.getCurrentTexture().createView(),s=i.beginRenderPass({colorAttachments:[{view:p,clearValue:{r:.5,g:.5,b:.5,a:1},loadOp:"clear",storeOp:"store"}],depthStencilAttachment:{view:b,depthClearValue:1,depthLoadOp:"clear",depthStoreOp:"store"}});s.setPipeline(h),s.setVertexBuffer(0,x),s.setBindGroup(0,v),s.draw(z),s.end(),e.queue.submit([i.finish()])});return()=>{C(),B()}}export{Y as render};
