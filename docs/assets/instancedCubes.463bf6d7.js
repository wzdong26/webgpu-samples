import{p as R}from"./position.frag.9060e7ac.js";import{p as w,u as O,v as B,a as T,b as V,g as z}from"./matrix.2969bbb4.js";import{o as L}from"./resizeObserver.84f51a4b.js";var q=`@binding(0) @group(0) var<storage, read> mvpMatrix : array<mat4x4<f32>>;\r
\r
struct VertexOutput {\r
    @builtin(position) Position: vec4<f32>,\r
    @location(0) fragUV: vec2<f32>,\r
    @location(1) fragPosition: vec4<f32>\r
};\r
\r
@vertex\r
fn main(\r
    @builtin(instance_index) index: u32,\r
    @location(0) position: vec4<f32>,\r
    @location(1) uv: vec2<f32>\r
) -> VertexOutput {\r
    var output: VertexOutput;\r
    output.Position = mvpMatrix[index] * position;\r
    output.fragUV = uv;\r
    output.fragPosition = 0.5 * (position + vec4<f32>(1.0));\r
    return output;\r
}`;function Y(o,a){const{on:r,off:n}=D(a),t=W(o,r);return async()=>{(await t)(),n()}}const _=["renderInstance","renderBundle"];function D(o){const a=document.createElement("select"),r=_.map(t=>{const e=document.createElement("option");return e.value=t,e.innerText=t,e});a.append(...r),o.append(a);let n;return{on:async(t,e)=>{n&&a.removeEventListener("input",n),n=async({target:s})=>{const{value:u}=s||{};await t(u)},a.addEventListener("input",n),e&&await n({target:a})},off:()=>{n&&a.removeEventListener("input",n),o.removeChild(a)}}}const f=1e3;function F(o){const a=[],r=new Float32Array(f*4*4);for(let n=0;n<f;n++){const t={x:Math.random()*40-20,y:Math.random()*40-20,z:-30-Math.random()*50},e={x:0,y:0,z:0},s={x:1,y:1,z:1};a.push({position:t,rotation:e,scale:s})}return function(t){t=t/1e3;for(let e=0;e<a.length-1;e++){const s=a[e];s.rotation.x=Math.sin(t+e),s.rotation.y=Math.cos(t+e);const u=z(o,s.position,s.rotation,s.scale);r.set(u,e*4*4)}return r}}async function W(o,a){var y,M;const{gpu:r}=navigator,n=await((y=r==null?void 0:r.requestAdapter)==null?void 0:y.call(r,{}));if(!n)throw Error("WebGPU not support! Adapter not found!");const t=(M=r.getPreferredCanvasFormat)==null?void 0:M.call(r);if(!t)throw Error("WebGPU not support! Adapter not found!");const e=await n.requestDevice(),s=o.getContext("webgpu"),{devicePixelRatio:u=1}=window;s.configure({device:e,format:t,alphaMode:"opaque"});const v=e.createRenderPipeline({vertex:{module:e.createShaderModule({code:q}),entryPoint:"main",buffers:[{attributes:[{shaderLocation:0,offset:0,format:`float32x${w}`},{shaderLocation:1,offset:4*w,format:`float32x${O}`}],arrayStride:4*(w+O),stepMode:"vertex"}]},fragment:{module:e.createShaderModule({code:R}),entryPoint:"main",targets:[{format:t}]},primitive:{topology:"triangle-list",cullMode:"back"},depthStencil:{depthWriteEnabled:!0,depthCompare:"less",format:"depth24plus"},layout:"auto"}),g=e.createBuffer({size:B.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST});e.queue.writeBuffer(g,0,B,0,B.length);const{write:C,setGroup:P}=I(e,v);let l,E;const b=i=>{const{width:d,height:c,clientHeight:p,clientWidth:m}=o;if(i&&d===m*u&&c===p*u)return;const h={width:o.clientWidth*u,height:o.clientHeight*u};Object.assign(o,h),l==null||l.destroy(),l=e.createTexture({size:h,format:"depth24plus",usage:GPUTextureUsage.RENDER_ATTACHMENT}),E=F(h.width/h.height)};b();const U=L(o,b);function G(){const i={colorAttachments:[{view:void 0,clearValue:{r:.5,g:.5,b:.5,a:1},loadOp:"clear",storeOp:"store"}],depthStencilAttachment:{view:l.createView(),depthClearValue:1,depthLoadOp:"clear",depthStoreOp:"store"}};return()=>{const d=e.createCommandEncoder();i.colorAttachments[0].view=s.getCurrentTexture().createView();const c=d.beginRenderPass(i);c.setPipeline(v),c.setVertexBuffer(0,g),P(c),c.draw(V,f),c.end(),e.queue.submit([d.finish()])}}function S(){const i=e.createRenderBundleEncoder({colorFormats:[t],depthStencilFormat:"depth24plus"});i.setPipeline(v),console.time("recordBundles");for(let p=0;p<f;p++)i.setVertexBuffer(0,g),P(i),i.draw(V,1,0,p);console.timeEnd("recordBundles");const d=[i.finish()],c={colorAttachments:[{view:void 0,clearValue:{r:0,g:0,b:0,a:1},loadOp:"clear",storeOp:"store"}],depthStencilAttachment:{view:l.createView(),depthClearValue:1,depthLoadOp:"clear",depthStoreOp:"store"}};return()=>{const p=e.createCommandEncoder();c.colorAttachments[0].view=s.getCurrentTexture().createView();const m=p.beginRenderPass(c);m.executeBundles(d),m.end(),e.queue.submit([p.finish()])}}let x;await a(i=>{i==="renderBundle"?x=S():x=G()},!0);const A=T(i=>{const d=E(i);C(d),x()});return()=>{A(),U()}}function I(o,a){const r=o.createBuffer({size:64*f,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),n=o.createBindGroup({layout:a.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:r}}]});return{write(t){o.queue.writeBuffer(r,0,t)},setGroup(t){t.setBindGroup(0,n)}}}export{Y as render};
